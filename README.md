桌面图标要求：自动排序，也就是一定要一个接一个排放
关于桌面图标的排列问题：希望能按照屏幕高度来判断一列能放多少个图标
图标固定宽高
一列就是一个 ul 列中的图标就是 ul 的 li

设备 height 除以 li 的 height = 一列图标个数（以后的限制条件）

对于图标设计：

1. 考虑到需要快速定位到点击的图标位置，所以采用了二维数组渲染
2. 考虑到要实现拖拽换位，所以使用了链表结构，方便实现插入删除操作
   综合考虑，通过链表进行记录图标的拖拽，然后二维数组则通过链表进行渲染
   (链表一个个节点插入到二维数组里，当到 y 轴个数极限时，x+1， y=0，继续添加)

特殊的情况（已解决）：
当往下一个图标拖动的时候出现特殊情况，preReplace=dragNode
以及当拖动第一个图标到第二个图标时也属于特殊情况 preDragNode=null

对于双击事件的判断：
利用 setTimeout，在规定时间内再点击才能触发双击事件（setTimeout 返回的函数作为变量判断）

对于双击打开文件设计：
使用通用组件 Application 作为整体框架，利用 solt 插槽来处理不同类型的文件展示不同的内容

打开网页的设计：
利用 iframe 当作一个个网页展示

打开 txt 文件的设计：
利用 textarea 作为记事本修改和展示内容

slot 里面给出是渲染的第几个，home 组件中在对应文件的 arr 数组中拿出对应位的 title，再在 home 中发送请求拿到对应的值，再进行渲染

其中实现页面选择和删除遇到的问题和解决过程：

1. 某些情况下删除 page，导致 activeIndex 出错，无法展示到正确的页面。
   经过筛查和调试后发现，是事件冒泡导致：每次点击关闭页面按钮触发事件后，冒泡触发到选择页面事件，导致可能出现选择了不存在的 index 情况。所以无法显示出正确的页面。

2.删除页面后，再次双击添加页面时，activeIndex 无法正确展示。
原因：通过子组件 watch 一个 prop 事件父级触发子组件的修改 activeIndex 事件过程中，watch 的变量方式有问题。

出现问题的方案：父级传给子组件 activeIndex 变量，父级中该值只在双击添加网页的时候，传递网页数量-1 的值给子组件，目的是让子组件 watch 该值后，触发修改 activeIndex 方法，实现每次双击后，activeIndex 都是最后一位的目的。
定位问题：当删除所有网页中某个网页时，数量已经-1，此时父级的 activeIndex 变量无法得知，还是上次的值。
然后当双击添加一个网页时，数量又+1，导致 activeIndex 和上次相等，那么显然子组件 watch 该值的函数无法触发，因为父级的该值根本没有改变。

解决方案：父级不传确切的 activeIndex 给子组件修改，因为值在两个组件中难以统一（没有用 vuex 的弊端），而是采用一个变量不断的变化，来提醒子组件，应该把 activeIndex 的值修改成网页中最后一位即可（具体实现：父级传一个 bool 值给子组件 watch，然后每次双击图标后，bool 值取反，意为提醒子组件修改 activeIndex 为网页中最后一位）

3.为什么打开页面时，不能进行拖动图标?
打开页面操作，数据拿的是图标二维数组中对应的位置，如果在打开页面的情况下，拖动图标，即修改了图标二位数组，那么由于数据响应式，通知了页面的数据也进行相应的改变，导致渲染出来的页面也会随着变化，使页面失去稳定性。

4.拖动窗口，当鼠标移动到 iframe 页面上时，失去预想的效果
问题原因：拖动网页窗口时，需要给 document 注册 mousemove 事件（优化用户体验），但由于网页是通过 iframe 实现的，当鼠标移动到 iframe 上面时，出了 document 的范围，无法触发 mousemove 事件，导致出现问题。
解决的方法：当点击时，用一个 div 覆盖住 iframe

5.在 Application 组件中（用于处理双击后打开的新窗口），根据数据给 dataMap 对象设置数据时，computed 无法获得新设置的内容
原因：dataMap 为对象，新添加属性的话需要手动调用 this.\$set 来给其添加响应式

6.对于 textarea，要实现 ctrl+s 保存和修改文本，但是无法输入新的文本
原因：实现 ctrl+s 要取消默认事件，否则触发浏览器的保存事件，取消 keydown 的默认事件后，导致 input 事件无法触发。
解决方法：修改取消默认事件的顺序：
问题写法：`<textarea @keydown.prevent.ctrl="handleKeyDown($event, data)" class="txt" v-model="data.content" />`
意为：该元素的所有keydown都阻止默认行为，只有按下ctrl，才会触发事件
导致所有keydown的默认行为都无法触发，即无法触发input事件

正确写法：`<textarea @keydown.ctrl.prevent="handleKeyDown($event, data)" class="txt" v-model="data.content" />`
意为：只有按下ctrl触发的keydown事件才阻止默认行为
所以只有按下ctrl+某些键的时候，才不会触发input事件
